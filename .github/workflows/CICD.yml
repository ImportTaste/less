name: CICD

# spell-checker:ignore (abbrev/acronyms) CICD CodeCOV MSVC MacOS MinGW ASAN TSAN LLVM UBSAN
# spell-checker:ignore (env/flags) Ccodegen Coverflow fsanitize CXXFLAGS
# spell-checker:ignore (jargon) SHAs deps softprops toolchain
# spell-checker:ignore (names) Peltoche rivy Xenial Bionic Bionic's
# spell-checker:ignore (shell/tools) choco clippy cmake ctest dmake dpkg esac fakeroot gmake grcov halium lcov libssl mkdir popd printf pushd rustc rustfmt rustup shopt xargs xcode valgrind libtsan
# spell-checker:ignore (misc) alnum gnueabihf issuecomment maint nullglob onexitbegin onexitend uutils libc multilib

env:
  PROJECT_NAME: less
  PROJECT_DESC: "`less` is more"

on: [push, pull_request]

jobs:
  CICD:
    name: ${{ matrix.job.name }} (${{ matrix.job.compiler }})
    runs-on: ${{ matrix.job.os }}
    strategy:
      fail-fast: false
      matrix:
        job:
          - { name: Ubuntu, os: ubuntu-latest, compiler: clang, arch: x64 }
          - { name: Ubuntu, os: ubuntu-latest, compiler: gcc, arch: x64 }
          # - { name: MacOS, os: macos-latest, compiler: xcode, version: "11.3" }
          - { name: Windows, os: windows-latest, compiler: cl, arch: x86 }
          - { name: Windows, os: windows-latest, compiler: cl, arch: x64 }
          # - { name: Windows, os: windows-latest, compiler: clang }
          - { name: Windows, os: windows-latest, compiler: gcc, arch: x64 }
    steps:
      - uses: actions/checkout@v1
      - name: Initialize workflow variables
        id: vars
        shell: bash
        run: |
          ## VARs setup
          # staging directory
          STAGING='_staging'
          echo set-output name=STAGING::${STAGING}
          echo ::set-output name=STAGING::${STAGING}
          # determine EXE suffix
          EXE_suffix="" ; case '${{ matrix.job.os }}' in windows-*) EXE_suffix=".exe" ;; esac;
          echo set-output name=EXE_suffix::${EXE_suffix}
          echo ::set-output name=EXE_suffix::${EXE_suffix}
          # parse commit reference info
          echo GITHUB_REF=${GITHUB_REF}
          echo GITHUB_SHA=${GITHUB_SHA}
          REF_NAME=${GITHUB_REF#refs/*/}
          unset REF_BRANCH ; case "${GITHUB_REF}" in refs/heads/*) REF_BRANCH=${GITHUB_REF#refs/heads/} ;; esac;
          unset REF_TAG ; case "${GITHUB_REF}" in refs/tags/*) REF_TAG=${GITHUB_REF#refs/tags/} ;; esac;
          REF_SHAS=${GITHUB_SHA:0:8}
          echo set-output name=REF_NAME::${REF_NAME}
          echo set-output name=REF_BRANCH::${REF_BRANCH}
          echo set-output name=REF_TAG::${REF_TAG}
          echo set-output name=REF_SHAS::${REF_SHAS}
          echo ::set-output name=REF_NAME::${REF_NAME}
          echo ::set-output name=REF_BRANCH::${REF_BRANCH}
          echo ::set-output name=REF_TAG::${REF_TAG}
          echo ::set-output name=REF_SHAS::${REF_SHAS}
          # package name
          PKG_suffix=".tar.gz" ; case '${{ matrix.job.target }}' in *-pc-windows-*) PKG_suffix=".zip" ;; esac;
          PKG_BASENAME=${PROJECT_NAME}-${REF_TAG:-$REF_SHAS}-${{ matrix.job.compiler }}.x${{ matrix.job.arch }}
          PKG_NAME=${PKG_BASENAME}${PKG_suffix}
          echo set-output name=PKG_suffix::${PKG_suffix}
          echo set-output name=PKG_BASENAME::${PKG_BASENAME}
          echo set-output name=PKG_NAME::${PKG_NAME}
          echo ::set-output name=PKG_suffix::${PKG_suffix}
          echo ::set-output name=PKG_BASENAME::${PKG_BASENAME}
          echo ::set-output name=PKG_NAME::${PKG_NAME}
          # deployable tag? (ie, leading "vM" or "M"; M == version number)
          unset DEPLOYABLE ; if [[ $REF_TAG =~ ^[vV]?[0-9].* ]]; then DEPLOYABLE='true' ; fi
          echo set-output name=DEPLOYABLE::${DEPLOYABLE:-<empty>/false}
          echo ::set-output name=DEPLOYABLE::${DEPLOYABLE}
          # * strip executable?
          STRIP="strip" ; case '${{ matrix.job.os }}' in windows-*) STRIP='' ;; esac;
          echo set-output name=STRIP::${STRIP:-<empty>/false}
          echo ::set-output name=STRIP::${STRIP}
      - name: Create all needed build/work directories
        shell: bash
        run: |
          ## create build/work space
          mkdir -p '${{ steps.vars.outputs.STAGING }}'
          mkdir -p '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}'
          mkdir -p '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/bin'
      - uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.job.arch }}
      - name: Install/setup prerequisites
        shell: bash
        run: |
          ## install/setup prerequisites
          case '${{ matrix.job.os }}' in
            ubuntu-*)
              sudo apt-get -y update
              sudo dpkg --add-architecture i386
              case '${{ matrix.job.compiler }}' in
                clang) sudo apt-get install -y clang g++-multilib ;;
                gcc) sudo apt-get install -y g++ g++-multilib ;;
              esac
            ;;
          esac
          case '${{ matrix.job.compiler }}' in
            cl) CC=cl ; CXX=cl ;;
            clang) CC=clang ; CXX=clang++ ;;
            gcc) CC=gcc ; CXX=g++ ;;
          esac
          echo "::set-env name=CC::${CC}"
          echo "::set-env name=CXX::${CXX}"
      - name: Info
        shell: bash
        run: |
          # Info
          ## commit info
          echo "## commit"
          echo GITHUB_REF=${GITHUB_REF}
          echo GITHUB_SHA=${GITHUB_SHA}
          ## tooling info display
          echo "## tooling"
          which cl >/dev/null 2>&1 && (cl 2>&1 | head -1) || true
          which clang >/dev/null 2>&1 && (clang --version | head -1) || true
          which gcc >/dev/null 2>&1 && (gcc --version | head -1) || true
          echo "CC=${CC}"
          echo "CXX=${CXX}"
      - name: Build
        shell: bash
        run: |
          case '${{ matrix.job.os }}' in
            ubuntu-*)
              sudo chmod +x ./configure
              sudo ./configure
            ;;
            windows-*)
              cp Makefile.win Makefile
            ;;
          esac
          make CC="${CC}" CXX="${CXX}" all
          ls -lR
          cp '${{ env.PROJECT_NAME }}${{ steps.vars.outputs.EXE_suffix }}' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/bin/'
          # cp 'lessecho${{ steps.vars.outputs.EXE_suffix }}' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/bin/'
          # cp 'lesskey${{ steps.vars.outputs.EXE_suffix }}' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/bin/'
      # - name: Test
      #   uses: actions-rs/cargo@v1
      #   with:
      #     use-cross: ${{ steps.vars.outputs.CARGO_USE_CROSS }}
      #     command: test
      #     args: --target=${{ matrix.job.target }} ${{ steps.vars.outputs.CARGO_TEST_OPTIONS}} ${{ matrix.job.cargo-options }} ${{ steps.vars.outputs.CARGO_FEATURES_OPTION }}
      - name: Archive executable artifacts
        uses: actions/upload-artifact@master
        with:
          name: ${{ env.PROJECT_NAME }}-${{ matrix.job.compiler }}.x${{ matrix.job.arch }}
          path: ${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/bin/${{ env.PROJECT_NAME }}${{ steps.vars.outputs.EXE_suffix }}
      - name: Package
        shell: bash
        run: |
          ## package artifact(s)
          ls -lR
          # # binary
          # cp 'less${{ steps.vars.outputs.EXE_suffix }}' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/'
          # `strip` binary (if needed)
          if [ -n "${{ steps.vars.outputs.STRIP }}" ]; then "${{ steps.vars.outputs.STRIP }}" '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/bin/${{ env.PROJECT_NAME }}${{ steps.vars.outputs.EXE_suffix }}' ; fi
          echo "after strip"
          # README and LICENSE
          # * spell-checker:ignore EADME ICENSE
          (shopt -s nullglob; for f in [R]"EADME"{,.*}; do cp $f '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/' ; done)
          (shopt -s nullglob; for f in [L]"ICENSE"{-*,}{,.*}; do cp $f '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/' ; done)
          echo "after README LICENSE"
          # core compressed package
          pushd '${{ steps.vars.outputs.STAGING }}/' >/dev/null
          case '${{ matrix.job.os }}' in
            windows-*) 7z -y a '${{ steps.vars.outputs.PKG_NAME }}' '${{ steps.vars.outputs.PKG_BASENAME }}'/* | tail -2 ;;
            *) tar czf '${{ steps.vars.outputs.PKG_NAME }}' '${{ steps.vars.outputs.PKG_BASENAME }}'/* ;;
          esac
          echo "compression done"
          popd >/dev/null
      - name: Publish
        uses: softprops/action-gh-release@v1
        if: steps.vars.outputs.DEPLOYABLE
        with:
          files: |
            ${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_NAME }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
